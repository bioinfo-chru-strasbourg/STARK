#!/bin/bash
#################################
##
## NGS environment
##
#################################

SCRIPT_NAME="STARKLaunch"
SCRIPT_DESCRIPTION="STARK launch RUN or FASTQ/BAM analysis"
SCRIPT_RELEASE="0.9b"
SCRIPT_DATE="04/10/2016"
SCRIPT_AUTHOR="Antony Le Bechec"
SCRIPT_COPYRIGHT="IRC"
SCRIPT_LICENCE="GNU-AGPL"

# Realse note
RELEASE_NOTES=$RELEASE_NOTES"# 0.9b-30/05/2016: Script creation\n";

# Script folder
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Configuration
ENV_CONFIG=$(find $SCRIPT_DIR/.. -name config.app)
source $ENV_CONFIG 1>/dev/null 2>/dev/null


# Header
function header () {
	cat $STARK_FOLDER_DOCS/HEADER
	#echo "#######################################";
	#echo "# $SCRIPT_NAME [$SCRIPT_RELEASE-$SCRIPT_DATE]";
	#echo "# $SCRIPT_DESCRIPTION ";
	#echo "# $SCRIPT_AUTHOR @ $SCRIPT_COPYRIGHT Â© $SCRIPT_LICENCE";
	#echo "#######################################";
}

# Release
function release () {
	cat $STARK_FOLDER_DOCS/RELEASE_NOTES
	#echo "# RELEASE NOTES:";
	#echo -e $RELEASE_NOTES
}

# Usage
function usage {
	echo "# USAGE: $(basename $0) --runs=<RUN>|--fastq=<FASTQ>|--ana=<FILE> [options...]";
	echo "# -e|--application|--app|--env=<APP|FILE>     APP name or APP file configuration of the APPLICATION.";
	echo "#                                             Must be in the STARK APPS folder if relative path";
	echo "#                                             Default: defined in the RUN SampleSheet, or default.app if not defined";
	echo "# -f|--fastq|--fastq_R1=<FILE1,FILE2,...>     List of FASTQ|BAM|SAM|CRAM (mandatory if no --runs or --config options)";
	echo "#                                             Formats: *fastq.gz|*fq.gz|*bam|*ubam|*cram|*ucram|*sam|*usam";
	echo "# -r|--runs=<STRING1,STRING2,...>             List of RUNs to analyse, from Illumina sequencers (mandatory if no --fastq or --config options).";
	echo "#                                             RUNS will be automatically searched in all ENV RUN folders, if necessary";
	echo "#                                             Format: RUN1,RUN2...";
	echo "# -w|--ana|--analysis|--json=<FILE>           Config file in JSON format listing options (mandatory if no --fastq or --runs options).";
	echo "# -l|--samplesheet=<FILE>                     Illumina SampleSheet.csv file";
	echo "#                                             Default: found in RUN folder";


	echo "# -i|--application_infos                      Applications informations.";
	echo "# -y|--pipelines_infos                        Pipelines informations.";
	echo "# -g|--release_infos                          Pipelines with tools and databases information.";
	echo "# -x|--tools_infos                            Tools release information.";
	echo "# --databases_infos                           Databases information.";

	echo "# -v|--verbose                                VERBOSE option";
	echo "# -d|--debug                                  DEBUG option";
	echo "# -n|--release                                RELEASE option";
	echo "# -h|--help                                   HELP option";
	echo "#";
	echo -e "#\n# RUN Analysis\n################";
	$STARK_FOLDER_BIN/launch.sh -h | grep "# [ |-]";
	echo -e "#\n# SAMPLE Analysis\n###################";
	$STARK_FOLDER_BIN/launch.sample.sh -h | grep "# [ |-]";
}

# header
header;

# launch.sh
# env:,runs:,aligners:,callers:,annotators:,filter_samples:,samplesheet:,parallelization:,remove:,application,help
# e:r:a:c:n:f:s:p:v:wh
# launch.sample.sh
# e:f:q:b:s:r:p:t:a:h
# env:,fastq_R1:,fastq_R2:,bed:,sample:,run:,pipelines:,threads:,adapters:,help

####################################################################################################################################
# Getting parameters from the input
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# ":" tells that the option has a required argument, "::" tells that the option has an optional argument, no ":" tells no argument
ARGS=$(getopt -o "e:r:f:l:w:t:iygxvdnh" --long "env:,app:,application:,runs:,fastq:,fastq_R1:,json:,ana:,analysis:,samplesheet:,threads:,application_infos,applications_infos,pipelines_infos,release_infos,tools_infos,databases_infos,verbose,debug,release,help" -- "$@" 2> /dev/null)
# || [ -z $@ ]
if [ $? -ne 0 ]; then
	:
	#echo $?
	#usage;
	#exit;
fi;
PARAM=$@
DEBUG=0
VERBOSE=0
#PARAM=$(echo $@ | tr "\n" " ")
#echo $PARAM;
#PARAM=$(echo $ARGS | sed s/--//gi);
#exit 0;

eval set -- "$ARGS"
while true
do
	#echo "$1=$2"
	#echo "Eval opts";
	case "$1" in
		-e|--env|--app|--application)
			APP="$2"
			shift 2
			;;
		-r|--runs)
			RUNS="$2"
			shift 2
			;;
		-f|--fastq|--fastq_R1)
			FASTQ=$2 #"$(echo $2 | tr "\n" " ")"
			shift 2
			;;
		-l|--samplesheet)
			SAMPLESHEET_INPUT="$2" #"$(echo $2 | tr "\n" " ")"
			shift 2
			;;
		-i|--application_infos|--applications_infos)
			APPLICATIONS_INFOS=1
			shift 1
			;;
		-y|--pipelines_infos)
			PIPELINES_INFOS=1
			shift 1
			;;
		-g|--release_infos)
			RELEASE_INFOS=1
			shift 1
			;;
		-x|--tools_infos)
			TOOLS_INFOS=1
			shift 1
			;;
		--databases_infos)
			DATABASES_INFOS=1
			shift 1
			;;
		-t|--threads)
			THREADS_INPUT="$2"
			shift 2
			;;
		-v|--verbose)
			VERBOSE=1
			shift 1
			;;
		-d|--debug)
			VERBOSE=1
			DEBUG=1
			shift 1
			;;
		-n|--release)
			release;
			exit 0
			;;
		-h|--help)
			usage
			exit 0
			;;
		-w|--json|--ana|--analysis)
			JSON="$2"
			shift 2
			;;
		--) shift
			break
			;;
		*) 	echo "# Option $1 is not recognized. " "Use -h or --help to display the help." && \
			exit 1
			;;
	esac
done

#		*) 	echo "# Option $1 is not recognized. " "Use -h or --help to display the help." && \
#			exit 1
#			;;

####################################################################################################################################
# Checking the input parameter
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if [ -z "$FASTQ" ] && [ -z "$RUNS" ] && [ -z "$JSON" ] && [ -z "$APPLICATIONS_INFOS" ] && [ -z "$PIPELINES_INFOS" ] && [ -z "$RELEASE_INFOS" ] && [ -z "$TOOLS_INFOS" ] && [ -z "$DATABASES_INFOS" ] && ((!$DEBUG)); then
	echo "Option --runs or --fastq or --applications_infos or --pipelines_infos or --release_infos or --tools_infos is required. " "Use -h or --help to display the help." && usage && exit 1;
fi
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#echo "if [ "$FASTQ" == "ollow" ] && [ "$THREADS_INPUT" == "he" ] && [ "$W" == "hite" ] && [ "$RUNS" == "abbit" ];"
if [ "$FASTQ" == "ollow" ] && [ "$THREADS_INPUT" == "he" ] && [ "$W" == "hite" ] && [ "$RUNS" == "abbit" ]; then
	echo "test";
	echo -e "\033[2J\033[?25l"; R=`tput lines` C=`tput cols`;: $[R--] ; while true
	do ( e=echo\ -e s=sleep j=$[RANDOM%C] d=$[RANDOM%R];for i in `eval $e {1..$R}`;
	do c=`printf '\\\\0%o' $[RANDOM%57+33]` ###  ###
	$e "\033[$[i-1];${j}H\033[32m$c\033[$i;${j}H\033[37m"$c; $s 0.1;if [ $i -ge $d ]
	then $e "\033[$[i-d];${j}H ";fi;done;for i in `eval $e {$[i-d]..$R}`; #[mat!rix]
	do echo -e "\033[$i;${j}f ";$s 0.1;done)& sleep 0.05;done #(c) 2011 -- [ BruXy ]
	exit 0;
fi;
#echo "if [ "$FASTQ" == "ollow" ] && [ "$THREADS_INPUT" == "he" ] && [ "$W" == "hite" ] && [ "$RUNS" == "abbit" ];"
#exit 0;

# ENV
#########

ENV=$(find_app "$APP" "$STARK_FOLDER_APPS")
source_app "$APP" "$STARK_FOLDER_APPS"

export ENV
export APP

# DEBUG
#########
if ((0)) && (($DEBUG)); then
	echo $STARK_FOLDER_BIN
	echo $STARK_FOLDER_APPS
	echo $STARK_FOLDER_DOCS
	echo $STARK_FOLDER_TOOLBOX
	echo $STARK_FOLDER_CONFIG
	echo $STARK_FOLDER
	echo "APP=$APP"
	echo "ASSEMBLY=$ASSEMBLY"
	echo "PIPELINES=$PIPELINES"
	echo "ALIGNERS=$ALIGNERS"
	echo "CALLERS=$CALLERS"
	echo "ANNOTATORS=$ANNOTATORS"
	echo "ASSEMBLY=$ASSEMBLY"
	echo "RULES=$RULES"
	exit 0;
fi;


#source_app "$APP" "$STARK_FOLDER_APPS"

# SOURCE ENV if exists
#if [ ! -z $ENV ] && [ -s $ENV ]; then
#	echo "#[INFO] APPLICATION file '"$(echo $ENV | sed s#$STARK_FOLDER_APPS#APPS#)"' found."
#	#source $ENV;
#	source_app $ENV
#else
#	echo "#[ERROR] NO APPLICATION file '$ENV' found."
#	exit 1
#fi;

APP_DELIMITER="|"


EXIT=0

# CONFIG
##########


if [ -e $JSON ] && [ "$JSON" != "" ]; then

	echo "#[INFO] Config file '$JSON' does exists."
	PARAM_JSON=$(echo "$PARAM " | sed "s/--analysis=[^ |$]*//gi" | sed "s/--json=[^ |$]*//gi" | sed "s/--ana=[^ |$]*//gi" | sed "s/-w [^ |$]*//gi")

	PARAM_STARK=$($STARK_FOLDER_BIN/json_to_options.py $JSON)
	if [ $? -eq 0 ]; then
	    (($DEBUG)) && echo $PARAM_STARK
	else
	    echo "#[ERROR] Analysis configuration file '$JSON' failed"
	    exit 1;
	fi

	#CMD=$(echo $0" "$PARAM_STARK" $PARAM_JSON")
	CMD=$(echo "$0 $PARAM_JSON $PARAM_STARK")
	echo "#[INFO] CMD=$CMD"
	echo ""

	eval $CMD;

	EXIT=1

elif [ "$JSON" != "" ]; then

	echo "[WARNING] Analysis configuration file '$JSON' does NOT exist"

fi;


# APPLICATIONS_INFOS
#######

if (($APPLICATIONS_INFOS)); then

	if [ ! -e $SAMPLESHEET_INPUT ]; then
		echo "#[ERROR] SampleSheet '$SAMPLESHEET_INPUT' does NOT exists."
		exit 0;
	fi;


	#SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

	RUNS_TEST=$RUNS

	echo ""
	echo "#[INFO] ######################"
	echo "#[INFO] #### APPLICATIONS ####"
	echo "#[INFO] ######################"
	echo ""
	RAW_LIST="";
	FOLDER_RUN_ORIGINAL=$FOLDER_RUN
	#echo "TRUC "$(echo $( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/env.*sh)
	#for ENV_DEF in $( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/env.*sh; do

	#for ENV_DEF in $STARK_FOLDER_APPS/*app; do
	#find $STARK_FOLDER_APPS -name '*app' | sort -t'/' -k2.2r -k2.1
	#find $STARK_FOLDER_APPS -name '*app' -type f | xargs ls -l --group-directories-first | sed s#$STARK_FOLDER_APPS/## #| sort -t'/' -k2.3 -k2.2 -k2.1
	#find $STARK_FOLDER_APPS -name '*app' -type f | sed s#$STARK_FOLDER_APPS/## | sort -f -t'/' -k2.3 -k2.2 -k2.1
	#exit 0
	#for ENV_DEF in $(find $STARK_FOLDER_APPS -name '*app' | sort -t'/' -k2.2r -k2.1); do
	for ENV_DEF in $(find $STARK_FOLDER_APPS -name '*.app' -type f | sed s#$STARK_FOLDER_APPS/## | sort -f -t'/' -k2.3 -k2.2 -k2.1) $(find $STARK_FOLDER_APPS -name '*.plugapp' -type f | sed s#$STARK_FOLDER_APPS/## | sort -f -t'/' -k2.3 -k2.2 -k2.1); do

		# FIND APP
		#APP=$($STARK_FOLDER_BIN/extract_variable_from_env.sh $ENV_DEF "APP_NAME");
		APP=$(source_app "$STARK_FOLDER_APPS/$ENV_DEF"  2>/dev/null; echo $APP_NAME)
		#APP=$(echo $(basename $ENV_DEF) | sed "s/^env.//gi" | sed "s/.sh$//gi" | sed "s/sh$//gi")
		if [ "$APP" == "" ]; then
			APP="default";
			ENV=$APP;
		fi

		#FIELD_SEP="\t"
		APP_INFOS=$(source_app "$STARK_FOLDER_APPS/$ENV_DEF"; echo -e "$APP_RELEASE\t$APP_DESCRIPTION\t$APP_GROUP\t$APP_PROJECT\t$FOLDER_RUN\t$FOLDER_RESULTS\t$FOLDER_REPOSITORY\t$PIPELINES\t$POST_ALIGNMENT_STEPS\t$HOWARD_ANNOTATION_REPORT")
		APP_RELEASE=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $1}')
		APP_DESCRIPTION=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $2}')
		APP_GROUP=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $3}')
		APP_PROJECT=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $4}')
		FOLDER_RUN=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $5}')
		FOLDER_RESULTS=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $6}')
		FOLDER_REPOSITORY=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $7}')
		PIPELINES=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $8}')
		POST_ALIGNMENT=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $9}')
		HOWARD_ANNOTATION_REPORT=$(echo -e "$APP_INFOS" | awk -F'\t' '{print $10}')


		#exit 0

		[ -z "$APP_DESCRIPTION" ] && APP_DESCRIPTION="-";
		[ -z "$APP_GROUP" ] && APP_GROUP="UNKNOWN";
		[ -z "$APP_PROJECT" ] && APP_PROJECT="UNKNOWN";

		# Application TYPE
		APP_TYPE="APP"
		[ "${ENV_DEF##*.}" == "plugapp" ] && APP_TYPE="plugAPP"

		# OUTPUT
		#if [ "$RUNS_TEST" == "" ]; then
		#echo "#[INFO] ## $APP ["$(echo $ENV_DEF | sed s#$STARK_FOLDER_APPS#APPS#)"]";
		#echo "#[INFO] ## $APP ["$(echo $ENV_DEF | sed s#$STARK_FOLDER_APPS/##)" | $APP_GROUP/$APP_PROJECT ]";
		echo "";
		echo "#[INFO] $APP:$APP_RELEASE ["$(echo $ENV_DEF | sed s#$STARK_FOLDER_APPS/##)"] [$APP_TYPE] ";
		#echo "#[INFO]    INFOS        $APP_INFOS";
		echo "#[INFO]    DESCRIPTION        $APP_DESCRIPTION";
		echo "#[INFO]    GROUP              $APP_GROUP";
		echo "#[INFO]    PROJECT            $APP_PROJECT";
		echo "#[INFO]    RUN                $FOLDER_RUN";
		echo "#[INFO]    RESULTS            $FOLDER_RESULTS";
		echo "#[INFO]    REPOSITORY         $FOLDER_REPOSITORY";
		echo "#[INFO]    PIPELINES          $PIPELINES "
		#echo -e "#[INFO]       $(echo $PIPELINES | sed "s/ /\n#[INFO]       /gi")";
		#echo "#[INFO]    POST_ALIGNMENT $POST_ALIGNMENT "
		echo "#[INFO]    POST ALIGNMENT     $POST_ALIGNMENT_STEPS "
		echo "#[INFO]    ANNOTATIONS        $HOWARD_ANNOTATION_REPORT "
		#fi;
		RAW_LIST=$RAW_LIST" $FOLDER_RUN"

	done;
	RAW_LIST=$(echo $RAW_LIST | sed "s/ /\n/gi" | sort | uniq | sed "s/\n/ /gi" );

	#echo "RAW_LIST=$RAW_LIST"

	if [ "$RUNS_TEST" != "" ]; then

		for RUN_TEST in $(echo $RUNS_TEST | tr "," " "); do

		echo "";
		echo "#[INFO] ### RUN '$RUN_TEST' ####";
		RUN_TEST_FOUND=0;
		MISEQ_FOLDER_FOUND="";
		if [ -d $FOLDER_RUN_ORIGINAL/$RUN_TEST ]; then
			RUN_TEST_FOUND=1;
			MISEQ_FOLDER_FOUND=$FOLDER_RUN_ORIGINAL;
		fi;

		if ((!$RUN_TEST_FOUND)); then
		for RAW_LIST_ONE in $RAW_LIST; do
			if [ -d $RAW_LIST_ONE/$RUN_TEST ] && ((!$RUN_TEST_FOUND)); then
				RUN_TEST_FOUND=1;
				MISEQ_FOLDER_FOUND=$RAW_LIST_ONE;
			fi;
		done;
		fi;

		if ((!$RUN_TEST_FOUND)); then
			echo "#[ERROR] RUN not found";
		else
			echo "#[INFO] RAW FOLDER $MISEQ_FOLDER_FOUND";
		fi;

		# Test SampleSheet to determine RUN_TEST possible Application/ENV
		if [ -z $SAMPLESHEET_INPUT ]; then
			SAMPLESHEET_INPUT=$MISEQ_FOLDER_FOUND/$RUN_TEST/SampleSheet.csv
		fi;

		if [ -e $SAMPLESHEET_INPUT ]; then
			RUN_GROUP=`grep -i 'Investigator Name' $SAMPLESHEET_INPUT | tr -d '\r\n' | cut -d \, -f 2 | cut -d \- -f 1`
			RUN_PROJECT=`grep -i 'Investigator Name' $SAMPLESHEET_INPUT | tr -d '\r\n' | cut -d \, -f 2 | cut -d \- -f 2`
			RUN_USER=`grep -i 'Investigator Name' $SAMPLESHEET_INPUT | tr -d '\r\n' | cut -d \, -f 2 | cut -d \- -f 3`
			RUN_APP_NAME="$RUN_GROUP-$RUN_PROJECT"

			# RUN ENV
			# ENV-AUTO in ENV allows looking for ENV depending on GROUP/PROJECT/USER
			RUN_ENV=$ENV;

			# SOURCE ENV if exists
			#if [ ! -z $ENV ] && [ -s $ENV ]; then
			#	echo "#[INFO] APPLICATION file '"$(echo $ENV | sed s#$STARK_FOLDER_APPS#APPS#)"' found."
			#source_app $ENV;
			#ENV=$(find_app "$APP" "$STARK_FOLDER_APPS")
			#source_app "$APP" "$STARK_FOLDER_APPS"
			#else
			#	echo "#[WARNING] NO APPLICATION file '$ENV' found."
			#fi;

			RUN_ENV=$(find_app "$RUN_APP_NAME" "$STARK_FOLDER_APPS")
			source_app "$RUN_APP_NAME" "$STARK_FOLDER_APPS"
			#[ "$RUN_ENV" == "" ] && RUN_ENV=$ENV;

			RUN_APP=$(source $RUN_ENV; echo $APP_NAME)
			if [ "$RUN_APP" == "" ]; then RUN_APP="default"; fi

			echo "#[INFO] DEFAULT APPLICATION detection $RUN_APP";

			awk '/Data/{y=1;next}y' $SAMPLESHEET_INPUT | tr -d '\r' | sed 's/,/\t/g' > $TMP_SYS_FOLDER/$RUN'_SampleSheet.csv_tmp'
			SAMPLES_PROJECT_LIST=$( C=1; for i in $(head $TMP_SYS_FOLDER/$RUN'_SampleSheet.csv_tmp' -n 1) ; do if [ $i == "Sample_Project" ] ; then break ; else C=$(( $C + 1 )) ; fi ; done ; cut -f $C $TMP_SYS_FOLDER/$RUN'_SampleSheet.csv_tmp' | sort -u | sed 's/Sample_Project//' );
			rm $TMP_SYS_FOLDER/$RUN'_SampleSheet.csv_tmp'
			echo "#[INFO] List of APPLICATION: "$(echo $SAMPLES_PROJECT_LIST);
			for SPL in $SAMPLES_PROJECT_LIST; do
				echo "#[INFO] - '$SPL' ["$(find_app "$SPL" "$STARK_FOLDER_APPS" | sed s#$STARK_FOLDER_APPS#APP#)"]";
			done;
		else
			echo "#[WARNNING] SAMPLESHEET '$SAMPLESHEET_INPUT' not found";
		fi;

		done;

	else
		echo "";
		echo "#[INFO] USE $(basename $0) --applications_infos --runs=<RUN> to detect RAW FOLDER and APPLICATION of RUN";
	fi;
		echo "";

	EXIT=1
	#exit 0;
fi;

# PIPELINES
##############

if (($PIPELINES_INFOS)); then

	echo ""
	echo "###################"
	echo "#### PIPELINES ####"
	echo "###################"
	echo ""

	PIPELINES_INFOS=$TMP_SYS_FOLDER/$RANDOM$RANDOM.pipelines
	MAKEFILE_PARAM=$TMP_SYS_FOLDER/$RANDOM$RANDOM.param
	touch $PIPELINES_INFOS $MAKEFILE_PARAM
	#source $ENV;
	make -e -f $STARK_FOLDER_BIN/NGSWorkflow.mk PARAM=$MAKEFILE_PARAM PIPELINES_INFOS=$PIPELINES_INFOS $PIPELINES_INFOS 1>/dev/null 2>/dev/null;
	sort -k1,2 $PIPELINES_INFOS | cut -d: -f1-3 | column -t -s ':'
	#make -e -f $STARK_FOLDER_BIN/NGSWorkflow.mk PARAM=$MAKEFILE_PARAM RELEASE_INFOS=$PIPELINES_INFOS $PIPELINES_INFOS 1>/dev/null 2>/dev/null;
	#cat $PIPELINES_INFOS
	rm $PIPELINES_INFOS $MAKEFILE_PARAM;

	EXIT=1
fi;



# TOOLS INFOS
#################

if (($TOOLS_INFOS)); then

	echo ""
	echo "####################"
	echo "#### TOOLS LIST ####"
	echo "####################"
	echo ""
	for T in $TOOLS_LIST; do
		VAR_VERSION=$T"_VERSION"; #echo ${!VAR_VERSION};
		VAR_DESCRIPTION=$T"_DESCRIPTION"; #echo ${!VAR_DESCRIPTION};
		VAR_REF=$T"_REF"; #echo ${!VAR_REF};
		echo "## $T ["${!VAR_VERSION}"]";
		echo "# "${!VAR_DESCRIPTION};
		echo "# "${!VAR_REF};
		echo ""
	done

	EXIT=1
fi;

# DATABASES INFOS
#################

if (($DATABASES_INFOS)); then

	echo ""
	echo "########################"
	echo "#### DATABASES LIST ####"
	echo "########################"
	#echo ""
	#echo "$ENV"
	for D in $DATABASES_LIST; do
		VAR_D=$D; #echo ${!VAR_VERSION};
		#VAR_DESCRIPTION=$T"_DESCRIPTION"; #echo ${!VAR_DESCRIPTION};
		#VAR_REF=$T"_REF"; #echo ${!VAR_REF};
		echo "## $D: "${!VAR_D}"";
		#echo ""
	done

	echo ""
	echo "##########################"
	echo "#### DATABASES CONFIG ####"
	echo "##########################"
	#echo ""
	for DC in $DATABASES_CONFIG_LIST; do
		VAR_DC=$DC; #echo ${!VAR_VERSION};
		#VAR_DESCRIPTION=$T"_DESCRIPTION"; #echo ${!VAR_DESCRIPTION};
		#VAR_REF=$T"_REF"; #echo ${!VAR_REF};
		echo "## $DC: "${!VAR_DC}"";
		#echo ""
	done

	EXIT=1
fi;


# RELEASE INFOS
#################

if (($RELEASE_INFOS)); then

	echo ""
	echo "##################"
	echo "#### RELEASES ####"
	echo "##################"
	echo ""

	RELEASE_INFOS=$TMP_SYS_FOLDER/$RANDOM$RANDOM.release
	MAKEFILE_PARAM=$TMP_SYS_FOLDER/$RANDOM$RANDOM.param
	touch $RELEASE_INFOS $MAKEFILE_PARAM

	#source $ENV;
	make -e -f $STARK_FOLDER_BIN/NGSWorkflow.mk PARAM=$MAKEFILE_PARAM RELEASE_INFOS=$RELEASE_INFOS $RELEASE_INFOS 1>/dev/null 2>/dev/null;
	cat $RELEASE_INFOS | sed "s/^## /\n## /"

	rm $RELEASE_INFOS $MAKEFILE_PARAM;

	EXIT=1
fi;
#echo "truc"; exit 0;


if (($EXIT)); then
	exit 0;
fi;






# FASTQ/BAM/CRAM/SAM SAMPLE
##################################

if [ ! -z "$FASTQ" ]; then # && [ -e "$FASTQ" ]; then
	# TEST FASTQs if exist

	(($VERBOSE)) && echo "#[INFO] Test Samples Analysis"

	FASTQ_EXISTS=1
	for F in $(echo $FASTQ | tr "," " "); do
		if [ ! -e $F ] || [ -d $F ]; then
			echo "#[WARNING] Input File '$F' does NOT exist"
			FASTQ_EXISTS=0;
		else
			(($VERBOSE)) && echo "#[INFO] Input File '$F' exists"
		fi;
	done;

	# Launch FASTQs analmysis if all FASTQs exist
	if (($FASTQ_EXISTS)); then
		#echo -e "#\n# Launch SAMPLE Analysis '$FASTQ'\n#"; # $PARAM
		echo "#[INFO] Start SAMPLE Analysis"
#exit 0
		echo ""
		$STARK_FOLDER_BIN/launch.sample.sh $PARAM
		EXIT=1
	else
		echo "#[ERROR] Input file(s) error"
	fi;

fi;


# Break analysis
if (($EXIT)); then
	exit 0;
fi;





# RUN (if no FASTQ files)
##############################

#FOLDER_RUN="/STARK/data/DATA/RAW/RUNS,/STARK/runs"
#FOLDER_RUN="/STARK/data/DATA/RAW/RUNS,/STARK/runs"
(($DEBUG)) && echo "#[INFO] RUN folders: $FOLDER_RUN"

if [ ! -z "$RUNS" ]; then

	(($VERBOSE)) && echo "#[INFO] Test Runs Analysis"

	RUNS_TO_LAUNCH=""
	for R in $(echo $RUNS | tr "," " "); do
		RUN_PATH=""
		if [ "$R" != "" ]; then
			# test if RUN full PATH
			(($DEBUG)) && echo "#[INFO] Search for RUN '$R' ";
			[ -d $R ] && RUN_PATH=$R;
			[ "$RUN_PATH" == "" ] && \
			for FR in $(echo $FOLDER_RUN | tr "," " "); do
				(($DEBUG)) && echo "#[INFO] Search for RUN '$R' in RUN folder '$FR' ";
				[ -d $FR/$R ] && RUN_PATH="$RUN_PATH$FR/$R " && echo "#[INFO] Input RUN '$R' found in RUN folder '$FR'"
			done;
			[ $(echo $RUN_PATH | wc -w) -gt 1 ] && echo "#[ERROR] Input Run '$R' found in multiple RUN folders: $RUN_PATH" && echo "" && exit 0;
			RUNS_TO_LAUNCH="$RUNS_TO_LAUNCH$RUN_PATH "
		fi;

	done;

	echo "#[INFO] Input RUN to launch: $RUNS_TO_LAUNCH";
	echo ""

	# Launch FASTQs analmysis if all FASTQs exist
	if (($(echo $RUNS_TO_LAUNCH | wc -w))); then
		for R in $RUNS_TO_LAUNCH; do

			R_NAME=$(basename $R)
			echo "#[INFO] Start Analysis for RUN '$R_NAME'"

			# Test if RAW Folder or DEM Folder

			if [ -e $R/RTAComplete.txt ]; then

				# RUN is a RAW RUN (BCL)
				echo "#[INFO] RUN analysis as a RAW folder (BCL)";

				# Find SampleSheet
				RUN_SAMPLESHEET=""
				# sampleSheet from Input
				[ ! -z $SAMPLESHEET_INPUT ] && [ -e $SAMPLESHEET_INPUT ] && RUN_SAMPLESHEET=$SAMPLESHEET_INPUT
				# sampleSheet within the RUN folder
				[ -z $RUN_SAMPLESHEET ] && RUN_SAMPLESHEET=$R/SampleSheet.csv
				# Echo
				[ ! -e $RUN_SAMPLESHEET ] && echo "#[ERROR] No SampleSheet for RUN '$R'" && exit 0;
				echo "#[INFO] SampleSheet found for RUN '$R': $RUN_SAMPLESHEET";

				DEM_SAMPLESHEET=$DEMULTIPLEXING_FOLDER/$R_NAME/SampleSheet.csv
				DEM_STARKCOMPLETE=$DEMULTIPLEXING_FOLDER/$R_NAME/STARKComplete.txt
				DEM_MANIFEST_LIST=$DEMULTIPLEXING_FOLDER/$R_NAME/STARKComplete.txt

				DEM_PARAM=""
				(($VERBOSE)) && DEM_PARAM="$DEM_PARAM --verbose "
				(($DEBUG)) && DEM_PARAM="$DEM_PARAM --debug "

				[ -e $R/RTAComplete.txt ] && [ ! -e $DEM_STARKCOMPLETE ] && echo "#[INFO] Start Demultiplexing for RUN '$R'" && echo "" && \
				$SCRIPT_DIR/demultiplexing.sh --app="$APP" --run=$R --demultiplex_folder=$DEMULTIPLEXING_FOLDER --samplesheet=$RUN_SAMPLESHEET --threads=$THREADS_INPUT $DEM_PARAM $DEM_PARAM #|| { echo "#[ERROR] Demultiplexing FAILED"; exit 1; }

				[ -e $DEM_STARKCOMPLETE ] && [ -e $DEM_SAMPLESHEET ] && echo "#[INFO] Demultiplexing completed"

				# Change RUN folder from RAW to DEM
				R=$DEMULTIPLEXING_FOLDER/$R_NAME

				echo ""

			fi;
			#RUN_SAMPLESHEET_TEST=$RUN_SAMPLESHEET
			# RUN is a DEM RUN (FASTQ)
			echo "#[INFO] RUN analysis as a DEM folder (Fastq)";

			# Find SampleSheet
			RUN_SAMPLESHEET=""
			# sampleSheet from Input
			[ ! -z $SAMPLESHEET_INPUT ] && [ -e $SAMPLESHEET_INPUT ] &&  RUN_SAMPLESHEET=$SAMPLESHEET_INPUT
			# sampleSheet within the RUN folder
			[ -z $RUN_SAMPLESHEET ] && RUN_SAMPLESHEET=$R/SampleSheet.csv
			# Echo
			[ ! -e $RUN_SAMPLESHEET ] && echo "#[ERROR] No SampleSheet for RUN '$R'" && exit 0;
			echo "#[INFO] SampleSheet found for RUN '$R': $RUN_SAMPLESHEET";

			RUN_NAME=$(basename $R)
			#echo "RUN_NAME=$RUN_NAME"; exit 0;
			# Clean sampleSheet
			#cat $RUN_SAMPLESHEET | | tr -d '\r' > $RUN_SAMPLESHEET.cleaned && cp

			# Main application
			#echo $RUN_SAMPLESHEET_TEST
			INVESTIGATOR_NAME=$(grep "Investigator Name" $RUN_SAMPLESHEET | awk -F, '{print $2}')
			MAIN_APP=$(grep "Investigator Name" $RUN_SAMPLESHEET | awk -F, '{print $2}' | awk -F$APP_DELIMITER '{print $1}')
			#APP=$(grep "Investigator Name" $RUN_SAMPLESHEET_TEST | awk -F, '{print $2}' | awk -F$APP_DELIMITER '{print $1}')
			#grep "Investigator Name" $RUN_SAMPLESHEET_TEST | awk -F, '{print $2}'
			#grep "Investigator Name" $RUN_SAMPLESHEET_TEST | awk -F, '{print $2}' | awk -F$APP_DELIMITER '{print $1}'
			(($VERBOSE)) && echo "#[INFO] Main APP: $MAIN_APP"

			#echo $INVESTIGATOR_NAME
			#echo $INVESTIGATOR_NAME | awk -F"," '{print $1}'
			#echo $INVESTIGATOR_NAME",-truc-machin" | cut -d"," -f 1

			# LIST of samples
			#DATA_SECTION_LINE=$(grep "^\[Data\]" $DEM_SAMPLESHEET -n | awk -F: '{print $1}')
			#SAMPLE_SECTION_FIRST_LINE=$(($DATA_SECTION_LINE+1))
			#SAMPLE_LIST=$(tail -n $(($SAMPLE_SECTION_FIRST_LINE-$(grep ^ -c $DEM_SAMPLESHEET))) $DEM_SAMPLESHEET | cut -d, -f1 | tr "\n" " ")
			SAMPLE_LIST=$(cat $RUN_SAMPLESHEET | awk '/\[Data\]/,/\[[^Data]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tail -n +2 | cut -d, -f1 | tr "\n" " ")
			(($VERBOSE)) && echo "#[INFO] List of samples: $SAMPLE_LIST";

			#awk '/Data/{y=1;next}y' $DEM_SAMPLESHEET | tr -d '\r' | sed 's/,/\t/g'
			SAMPLE_PROJECT_FIELD=1;
			MANIFEST_INDEX_FIELD=1;
			C=1
			#for i in $(awk '/Data/{y=1;next}y' $DEM_SAMPLESHEET | tr -d '\r' | sed 's/,/\t/g' | head -n 1) ; do
			for i in $(cat $RUN_SAMPLESHEET | awk '/\[Data\]/,/\[[^Data]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tr -d '\r' | sed 's/,/\t/g' | head -n 1) ; do
				[ $i == "Sample_Project" ] && SAMPLE_PROJECT_FIELD=$C
				[ $i == "Manifest" ] && MANIFEST_INDEX_FIELD=$C
				C=$(( $C + 1 )) ;
			done
			#(($DEBUG)) && echo "SAMPLE_PROJECT_FIELD=$SAMPLE_PROJECT_FIELD"
			#(($DEBUG)) && echo "MANIFEST_FIELD=$MANIFEST_INDEX_FIELD"
			#awk '/Data/{y=1;next}y' $DEM_SAMPLESHEET | tr -d '\r' | awk -F, "{print \$1\"\t\"\$$SAMPLE_PROJECT_FIELD\"\t\"\$$MANIFEST_INDEX_FIELD}"
			#(($DEBUG)) && \
			#cat $RUN_SAMPLESHEET | awk '/\[Data\]/,/\[[^Data]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tail -n +2 | tr -d '\r' | awk -F, "{print \$1\"\t\"\$$SAMPLE_PROJECT_FIELD\"\t\"\$$MANIFEST_INDEX_FIELD}"

			#(($DEBUG)) && \
			#cat $RUN_SAMPLESHEET | awk '/\[Data\]/,/\[[^Data]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tail -n +2 | tr -d '\r'
			#(($DEBUG)) && \
			#cat $RUN_SAMPLESHEET | awk '/\[Manifests\]/,/\[[^Manifest]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' #| head -n -1 | tail -n +2 #| awk '{s+=$2}END{print s}'


			# Create config
			#RUN_CONFIG_FILE_TAB=$R/config.tab
			#> $RUN_CONFIG_FILE_TAB
			APP_LIST=""
			for L in $(cat $RUN_SAMPLESHEET | awk '/\[Data\]/,/\[[^Data]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tail -n +2 | tr -d '\r'); do
				# SAMPLE ID/NAME
				SAMPLE_ID=$(echo $L | cut -d, -f1)
				SAMPLE_NAME=$(echo $L | cut -d, -f2)
				[ -z $SAMPLE_NAME ] && SAMPLE_NAME=$SAMPLE_ID
				# SAMPLE FASTQ R1/R2
				# P1431B_S6_I1_001.fastq.gz
				SAMPLE_FASTQ_R1_PATTERN=$SAMPLE_NAME'_S*_R1_*.fastq.gz'
				SAMPLE_FASTQ_R2_PATTERN=$SAMPLE_NAME'_S*_R2_*.fastq.gz'
				#echo $SAMPLE_FASTQ_R1_PATTERN
				SAMPLE_FASTQ_R1=$(find $R -name "$SAMPLE_FASTQ_R1_PATTERN")
				SAMPLE_FASTQ_R2=$(find $R -name "$SAMPLE_FASTQ_R2_PATTERN")
				# APP
				SAMPLE_APP="$(echo $L | cut -d, -f$SAMPLE_PROJECT_FIELD | awk -F$APP_DELIMITER '{print $1}')"
				[ -z $SAMPLE_APP ] && SAMPLE_APP=$MAIN_APP
				# CONFIG_TAB
				CONFIG_FILE_TAB=$R/$SAMPLE_APP.config.tab
				# Manifest Name
				MANIFEST_ID=$(echo $L | cut -d, -f$MANIFEST_INDEX_FIELD)
				MANIFEST_FILENAME=$(cat $RUN_SAMPLESHEET | awk '/\[Manifests\]/,/\[[^Manifest]/' | grep "^\[" -v | sed '/^[[:space:]]*$/d' | tr -d '\r' | awk -F, -v MANIFEST_ID=$MANIFEST_ID '$1==MANIFEST_ID{print $2}')
				# Manifest File
				[ -e $R/$MANIFEST_FILENAME ] && MANIFEST_FILE=$R/$MANIFEST_FILENAME && (($VERBOSE)) && echo "#[INFO] Manifest file found for sample '$SAMPLE_NAME': $MANIFEST_FILE" #|| echo "#[WARNING] Manifest file NOT found: $MANIFEST_FILENAME"
				# Genes File
				[ -e $R/$MANIFEST_FILENAME.genes ] && MANIFEST_GENES_FILE=$R/$MANIFEST_FILENAME.genes && (($VERBOSE)) &&  echo "#[INFO] Manifest Genes file found for sample '$SAMPLE_NAME': $MANIFEST_GENES_FILE" #|| echo "#[INFO] Manifest Genes file NOT found: $MANIFEST_FILENAME.genes"
				# Transcripts File
				[ -e $R/$MANIFEST_FILENAME.transcripts ] && MANIFEST_TRANSCRIPTS_FILE=$R/$MANIFEST_FILENAME.transcripts && (($VERBOSE)) &&  echo "#[INFO] Manifest Transcripts file found for sample '$SAMPLE_NAME': $MANIFEST_TRANSCRIPTS_FILE" #|| echo "#[INFO] Manifest Transcripts file NOT found: $MANIFEST_FILENAME.transcripts"

				APP_LIST=$(echo "$APP_LIST $SAMPLE_APP" | tr " " "\n" | sort -u | tr "\n" " ")
				echo "$SAMPLE_APP,$SAMPLE_ID,$SAMPLE_NAME,$SAMPLE_FASTQ_R1,$SAMPLE_FASTQ_R2,$MANIFEST_FILE,$MANIFEST_GENES_FILE,$MANIFEST_TRANSCRIPTS_FILE" >> $CONFIG_FILE_TAB
			done;


			#(($DEBUG)) && cat $RUN_CONFIG_FILE_TAB
			(($DEBUG)) && cat $R/*.config.tab | sort -u

			# Create config
			#for APP_ONE in $APP_LIST; do
			#ls $R/*.config.tab; exit 0;
			for APP_ONE_RUN_CONFIG_FILE in $R/*.config.tab; do
				echo "APP_ONE_RUN_CONFIG_FILE=$APP_ONE_RUN_CONFIG_FILE"
				APP_ONE=$(basename $APP_ONE_RUN_CONFIG_FILE | sed s/.config.tab//)
				echo "APP_ONE=$APP_ONE"
				RUN_CONFIG_FILE=$R/$APP_ONE.config.json
				> $RUN_CONFIG_FILE
				echo "{" >> $RUN_CONFIG_FILE
				# APP
				echo "\"app\":\"$APP_ONE\"," >> $RUN_CONFIG_FILE
				# RUN
				echo "\"run\":\"$RUN_NAME\"," >> $RUN_CONFIG_FILE
				# SAMPLE NAME
				echo "\"sample\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u| awk -F"," -v APP=$APP_ONE '$1==APP{print $3}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE
				# FASTQ R1/R2
				echo "\"fastq_R1\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u | awk -F"," -v APP=$APP_ONE '$1==APP{print $4}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE
				echo "\"fastq_R2\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u| awk -F"," -v APP=$APP_ONE '$1==APP{print $5}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE
				# MANIFEST
				echo "\"manifest\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u| awk -F"," -v APP=$APP_ONE '$1==APP{print $6}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE
				# GENES
				echo "\"genes\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u| awk -F"," -v APP=$APP_ONE '$1==APP{print $7}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE
				# MANIFEST
				echo "\"transcripts\":\""$(cat $APP_ONE_RUN_CONFIG_FILE | sort -u| awk -F"," -v APP=$APP_ONE '$1==APP{print $8}' | tr '\n' ',' | sed s/,$//)"\"," >> $RUN_CONFIG_FILE

				# REPOSITORY
				echo "\"repository\":\"$FOLDER_REPOSITORY\"" >> $RUN_CONFIG_FILE

				#echo "\"comment\":\"Analysis for APP $APP_ONE\"" >> $RUN_CONFIG_FILE
				echo "}" >> $RUN_CONFIG_FILE

				(($DEBUG)) && cat $RUN_CONFIG_FILE
				(($DEBUG)) && $STARK_FOLDER_BIN/json_to_options.py $RUN_CONFIG_FILE
			done;

			# Launch config.json
			for APP_ONE_RUN_CONFIG_FILE_JSON in $R/*.config.json; do
				(($DEBUG)) && echo $APP_ONE_RUN_CONFIG_FILE_JSON
				CMD="$STARK_FOLDER_BIN/STARK $PARAM --analysis=$APP_ONE_RUN_CONFIG_FILE_JSON " # --repository=$FOLDER_REPOSITORY
				(($DEBUG)) && echo $CMD
				eval $CMD
			done;

			echo ""

			#$STARK_FOLDER_BIN/launch.sh $PARAM
		done;


		EXIT=1
	fi;



	#exit 0;
fi;

exit 0;
# Break analysis
if (($EXIT)); then
	exit 0;
fi;


# If nothing...
##################

echo ""

usage;

exit 0;
